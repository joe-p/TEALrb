#pragma version 6
b main

helper_subroutine: // helper_subroutine(asa, axfer_txn)
    store 0 // helper_subroutine: axfer_txn [axfer]

    store 1 // helper_subroutine: asa [asset]

    load 0 // helper_subroutine: axfer_txn [axfer]
    gtxns Sender
    load 1 // helper_subroutine: asa [asset]
    asset_params_get AssetCreator
    pop
    ==
    assert

    retsub

some_abi_method: // some_abi_method(asa, axfer_txn, another_app, some_number)
    txna Assets 0
    store 2 // some_abi_method: asa [asset] Some asset

    txn GroupIndex
    int 1
    -
    store 3 // some_abi_method: axfer_txn [axfer] A axfer txn

    txna Applications 0
    store 4 // some_abi_method: another_app [application] Another app

    txna ApplicationArgs 1
    store 5 // some_abi_method: some_number [uint64]

    load 2 // some_abi_method: asa [asset] Some asset
    asset_params_get AssetUnitName
    swap
    pop
    assert

    load 3 // some_abi_method: axfer_txn [axfer] A axfer txn
    gtxns Sender
    txn Sender
    ==
    assert

    load 4 // some_abi_method: another_app [application] Another app
    app_params_get AppExtraProgramPages
    swap
    pop
    assert

    load 2 // some_abi_method: asa [asset] Some asset
    load 3 // some_abi_method: axfer_txn [axfer] A axfer txn
    callsub helper_subroutine // calling helper_subroutine calls a subroutine

    
    // calling helper_teal_method writes TEAL in-place
    load 2 // some_abi_method: asa [asset] Some asset
    load 3 // some_abi_method: axfer_txn [axfer] A axfer txn
    gtxns Sender
    asset_params_get AssetCreator
    pop
    ==
    assert

    load 5 // some_abi_method: some_number [uint64]
    int 1
    +
    itob
    byte "151f7c75"
    concat
    log

    retsub

some_subroutine: // some_subroutine(n, m)
    store 6 // some_subroutine: m [bytes] Some bytes

    store 7 // some_subroutine: n [uint64] Some number

    load 6 // some_subroutine: m [bytes] Some bytes
    log

    load 7 // some_subroutine: n [uint64] Some number
    int 1
    +
    retsub

main:
    txna ApplicationArgs 0
    byte "a78bd94e"
    ==
    bz if0_else0

    callsub some_abi_method

    int 1
    return

    b if0_end

    if0_else0:
    if0_end:
    
    // This comment will show in TEAL
    // raw teal
    byte "Key One" // this will be an in-line comment
    int 111
    app_global_put

    int 100
    int 200
    +
    
    // single method call
    byte "Key Two"
    int 222
    app_global_put

    
    // two step method call
    byte "Key Three" // string literals are implicitly bytes
    int 333
    app_global_put

    
    // Global put/get as hash
    byte "Key Four"
    int 444
    app_global_put

    byte "Key Five"
    app_global_get
    
    // Local put/get as hash
    txn Sender
    byte "Local Key"
    byte "Some Value"
    app_local_put

    txn Receiver
    byte "Local Key"
    app_local_get
    
    // using variables
    byte "Key Four"
    int 444
    app_global_put

    
    // combining raw teal with conditionals
    byte "Bad Key"
    app_global_get
    bz if1_else0

    err

    b if1_end

    if1_else0:
    if1_end:
    
    // more complex conditionals
    byte "First Word"
    app_global_get
    byte "Hi"
    ==
    bz if2_else0

    byte "Second Word"
    byte "Mom"
    app_global_put

    b if2_end

    if2_else0:
    byte "First Word"
    app_global_get
    byte "Hello"
    ==
    bz if2_else1

    byte "Second Word"
    byte "World"
    app_global_put

    b if2_end

    if2_else1:
    byte "First Word"
    app_global_get
    byte "Howdy"
    ==
    bz if2_else2

    byte "Second Word"
    byte "Partner"
    app_global_put

    b if2_end

    if2_else2:
    byte "Second Word"
    byte "???"
    app_global_put

    if2_end:
    
    // calling methods
    // subroutine
    int 1
    byte "one"
    callsub some_subroutine

    
    // teal method
    int 3
    int 4
    +
    
    // ruby method
    int 11
    
    // accessing specific indexes/fields
    gtxn 0 Sender // gtxn(0, 'Sender')
    gtxn 0 Sender // Gtxn.sender(0)
    gtxn 0 Sender // Gtxn[0].sender
    gtxn 0 Sender // gtxn_var.sender
    
    // manual branching
    b manual_br

    byte "Unreachable"
    app_global_get
manual_br:
    byte "Manual Br"
    app_global_get
    
    // placeholders
    byte "Some Key"
    REPLACE_ME
    app_global_put

    gtxn 1 ANOTHER_THING_TO_REPLACE
    
    // TxnType enums
    int pay
    
    // store/load to named scratch slots
    int 123
    store 8 // some key

    load 8 // some key
    int 321
    store 9 // another key

    load 9 // another key
    
    // while loops
while0:
    byte "counter"
    app_global_get
    int 3
    <
    bz end_while0

    byte "counter"
    byte "counter"
    app_global_get
    int 1
    +
    app_global_put

    b while0

end_while0:
    
    // opcodes with "maybe" values
    // using app_global_ex_exists? and app_global_ex_value
    int 1337
    byte "some_key"
    app_global_get_ex
    swap
    pop
    bz if3_else0

    int 1337
    byte "some_key"
    app_global_get_ex
    pop
    b if3_end

    if3_else0:
    byte "some_key does not exist"
    log

    if3_end:
    
    // using app_global_get_ex and store/load
    int 1337
    byte "some_key"
    app_local_get_ex
    store 0

    store 1

    load 0
    bz if4_else0

    load 1
    b if4_end

    if4_else0:
    byte "some_key does not exist"
    log

    if4_end:
    
    // Off-chain encoding
    byte 0x80 // bool: true
    byte 0x00000018 // uint32: 24
    byte 0x007b // ufixed16x2: 1.23
    byte 0x0002007b009c // ufixed16x2[2]: [1.23, 1.56]
    byte 0x007b009c // ufixed16x2[]: [1.23, 1.56]
    byte 0x8000000018007b // (bool, uint32, ufixed16x2): [true, 24, 1.23]
    
    // On-chain encoding
    int 1
    // Encode bool from stack
    !
    bz if5_else0

    byte 0x80
    b if5_end

    if5_else0:
    byte 0x00
    if5_end:
    int 24
    itob
    // Encode uint72 from stack
    store 10 // Uint72_input

    load 10 // Uint72_input
    len
    int 9
    <
    bz if6_else0

    byte 0x000000000000000000
    load 10 // Uint72_input
    b|
    b if6_end

    if6_else0:
    load 10 // Uint72_input
    len
    store 11 // Uint72_input_len

    load 10 // Uint72_input
    load 11 // Uint72_input_len
    int 9
    -
    load 11 // Uint72_input_len
    substring3
    if6_end:
    int 24
    itob
    // Encode uint16 from stack
    store 12 // Uint16_input

    load 12 // Uint16_input
    len
    int 2
    <
    bz if7_else0

    byte 0x0000
    load 12 // Uint16_input
    b|
    b if7_end

    if7_else0:
    load 12 // Uint16_input
    len
    store 13 // Uint16_input_len

    load 12 // Uint16_input
    load 13 // Uint16_input_len
    int 2
    -
    load 13 // Uint16_input_len
    substring3
    if7_end:
    
    // inline if statement
    btoi
    int 10
    >
    bz if8_else0

    b label

    b if8_end

    if8_else0:
    if8_end:
    
    // Accessing arrays
    // Assets[0].creator
    txna Assets 0
    asset_params_get AssetCreator
    pop
    
    // Accounts[1].balance?
    txna Accounts 1
    acct_params_get AcctBalance
    swap
    pop
    
    // Apps[1 + 1].creator
    int 1
    int 1
    +
    txnas Applications
    app_params_get AppCreator
    pop
    
    // sratch var shorthand with $
    int 123
    store 14 // another_scatch_var

    load 14 // another_scatch_var